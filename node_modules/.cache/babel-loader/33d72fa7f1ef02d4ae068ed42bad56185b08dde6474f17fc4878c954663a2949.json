{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createValidatePrune = exports.createIsPrune = exports.createAssertPrune = exports.createPrune = exports.createValidateClone = exports.createIsClone = exports.createAssertClone = exports.createClone = exports.createRandom = exports.createValidateStringify = exports.createIsStringify = exports.createAssertStringify = exports.createStringify = exports.createValidateParse = exports.createAssertParse = exports.createIsParse = exports.createValidateEquals = exports.createEquals = exports.createAssertEquals = exports.createValidate = exports.createIs = exports.createAssertType = exports.createAssert = exports.validatePrune = exports.isPrune = exports.assertPrune = exports.prune = exports.validateClone = exports.isClone = exports.assertClone = exports.clone = exports.random = exports.metadata = exports.validateStringify = exports.isStringify = exports.assertStringify = exports.stringify = exports.validateParse = exports.isParse = exports.assertParse = exports.application = exports.validateEquals = exports.equals = exports.assertEquals = exports.validate = exports.is = exports.assertType = exports.assert = void 0;\nvar Namespace_1 = require(\"./functional/Namespace\");\n__exportStar(require(\"./schemas/IJsonApplication\"), exports);\n__exportStar(require(\"./schemas/IJsonComponents\"), exports);\n__exportStar(require(\"./schemas/IJsonSchema\"), exports);\n__exportStar(require(\"./IRandomGenerator\"), exports);\n__exportStar(require(\"./IValidation\"), exports);\n__exportStar(require(\"./Primitive\"), exports);\n__exportStar(require(\"./TypeGuardError\"), exports);\nfunction assert() {\n  halt(\"assert\");\n}\nexports.assert = assert;\nObject.assign(assert, Namespace_1.Namespace.assert(\"assert\"));\nfunction assertType() {\n  halt(\"assertType\");\n}\nexports.assertType = assertType;\nObject.assign(assertType, Namespace_1.Namespace.assert(\"assertType\"));\nfunction is() {\n  halt(\"is\");\n}\nexports.is = is;\nObject.assign(is, Namespace_1.Namespace.assert(\"is\"));\nfunction validate() {\n  halt(\"validate\");\n}\nexports.validate = validate;\nObject.assign(validate, Namespace_1.Namespace.validate());\nfunction assertEquals() {\n  halt(\"assertEquals\");\n}\nexports.assertEquals = assertEquals;\nObject.assign(assertEquals, Namespace_1.Namespace.assert(\"assertEquals\"));\nfunction equals() {\n  halt(\"equals\");\n}\nexports.equals = equals;\nObject.assign(equals, Namespace_1.Namespace.is());\nfunction validateEquals() {\n  halt(\"validateEquals\");\n}\nexports.validateEquals = validateEquals;\nObject.assign(validateEquals, Namespace_1.Namespace.validate());\nfunction application() {\n  halt(\"application\");\n}\nexports.application = application;\nfunction assertParse() {\n  halt(\"assertParse\");\n}\nexports.assertParse = assertParse;\nObject.assign(assertParse, Namespace_1.Namespace.assert(\"assertParse\"));\nfunction isParse() {\n  halt(\"isParse\");\n}\nexports.isParse = isParse;\nObject.assign(isParse, is);\nfunction validateParse() {\n  halt(\"validateParse\");\n}\nexports.validateParse = validateParse;\nObject.assign(validateParse, validate);\nfunction stringify() {\n  halt(\"stringify\");\n}\nexports.stringify = stringify;\nObject.assign(stringify, Namespace_1.Namespace.stringify(\"stringify\"));\nfunction assertStringify() {\n  halt(\"assertStringify\");\n}\nexports.assertStringify = assertStringify;\nObject.assign(assertStringify, Namespace_1.Namespace.assert(\"assertStringify\"));\nObject.assign(assertStringify, Namespace_1.Namespace.stringify(\"assertStringify\"));\nfunction isStringify() {\n  halt(\"isStringify\");\n}\nexports.isStringify = isStringify;\nObject.assign(isStringify, Namespace_1.Namespace.is());\nObject.assign(isStringify, Namespace_1.Namespace.stringify(\"isStringify\"));\nfunction validateStringify() {\n  halt(\"validateStringify\");\n}\nexports.validateStringify = validateStringify;\nObject.assign(validateStringify, Namespace_1.Namespace.validate());\nObject.assign(validateStringify, Namespace_1.Namespace.stringify(\"validateStringify\"));\nfunction metadata() {\n  halt(\"metadata\");\n}\nexports.metadata = metadata;\nfunction random() {\n  halt(\"random\");\n}\nexports.random = random;\nObject.assign(random, Namespace_1.Namespace.random());\nfunction clone() {\n  halt(\"clone\");\n}\nexports.clone = clone;\nObject.assign(clone, Namespace_1.Namespace.clone(\"clone\"));\nfunction assertClone() {\n  halt(\"assertClone\");\n}\nexports.assertClone = assertClone;\nObject.assign(assertClone, Namespace_1.Namespace.assert(\"assertClone\"));\nObject.assign(assertClone, Namespace_1.Namespace.clone(\"assertClone\"));\nfunction isClone() {\n  halt(\"isClone\");\n}\nexports.isClone = isClone;\nObject.assign(isClone, Namespace_1.Namespace.is());\nObject.assign(isClone, Namespace_1.Namespace.clone(\"isClone\"));\nfunction validateClone() {\n  halt(\"validateClone\");\n}\nexports.validateClone = validateClone;\nObject.assign(validateClone, Namespace_1.Namespace.validate());\nObject.assign(validateClone, Namespace_1.Namespace.clone(\"validateClone\"));\nfunction prune() {\n  halt(\"prune\");\n}\nexports.prune = prune;\nObject.assign(prune, Namespace_1.Namespace.prune(\"prune\"));\nfunction assertPrune() {\n  halt(\"assertPrune\");\n}\nexports.assertPrune = assertPrune;\nObject.assign(assertPrune, Namespace_1.Namespace.assert(\"assertPrune\"));\nObject.assign(assertPrune, Namespace_1.Namespace.prune(\"assertPrune\"));\nfunction isPrune() {\n  halt(\"isPrune\");\n}\nexports.isPrune = isPrune;\nObject.assign(isPrune, Namespace_1.Namespace.is());\nObject.assign(isPrune, Namespace_1.Namespace.prune(\"isPrune\"));\nfunction validatePrune() {\n  halt(\"validatePrune\");\n}\nexports.validatePrune = validatePrune;\nObject.assign(validatePrune, Namespace_1.Namespace.prune(\"validatePrune\"));\nObject.assign(validatePrune, Namespace_1.Namespace.validate());\nfunction createAssert() {\n  halt(\"createAssert\");\n}\nexports.createAssert = createAssert;\nObject.assign(createAssert, assert);\nfunction createAssertType() {\n  halt(\"createAssertType\");\n}\nexports.createAssertType = createAssertType;\nObject.assign(createAssertType, assertType);\nfunction createIs() {\n  halt(\"createIs\");\n}\nexports.createIs = createIs;\nObject.assign(createIs, is);\nfunction createValidate() {\n  halt(\"createValidate\");\n}\nexports.createValidate = createValidate;\nObject.assign(createValidate, validate);\nfunction createAssertEquals() {\n  halt(\"createAssertEquals\");\n}\nexports.createAssertEquals = createAssertEquals;\nObject.assign(createAssertEquals, assertEquals);\nfunction createEquals() {\n  halt(\"createEquals\");\n}\nexports.createEquals = createEquals;\nObject.assign(createEquals, equals);\nfunction createValidateEquals() {\n  halt(\"createValidateEquals\");\n}\nexports.createValidateEquals = createValidateEquals;\nObject.assign(createValidateEquals, validateEquals);\nfunction createIsParse() {\n  halt(\"createIsParse\");\n}\nexports.createIsParse = createIsParse;\nObject.assign(createIsParse, isParse);\nfunction createAssertParse() {\n  halt(\"createAssertParse\");\n}\nexports.createAssertParse = createAssertParse;\nObject.assign(createAssertParse, assertParse);\nfunction createValidateParse() {\n  halt(\"createValidateParse\");\n}\nexports.createValidateParse = createValidateParse;\nObject.assign(createValidateParse, validateParse);\nfunction createStringify() {\n  halt(\"createStringify\");\n}\nexports.createStringify = createStringify;\nObject.assign(createStringify, stringify);\nfunction createAssertStringify() {\n  halt(\"createAssertStringify\");\n}\nexports.createAssertStringify = createAssertStringify;\nObject.assign(createAssertStringify, assertStringify);\nfunction createIsStringify() {\n  halt(\"createIsStringify\");\n}\nexports.createIsStringify = createIsStringify;\nObject.assign(createIsStringify, isStringify);\nfunction createValidateStringify() {\n  halt(\"createValidateStringify\");\n}\nexports.createValidateStringify = createValidateStringify;\nObject.assign(createValidateStringify, validateStringify);\nfunction createRandom() {\n  halt(\"createRandom\");\n}\nexports.createRandom = createRandom;\nObject.assign(createRandom, random);\nfunction createClone() {\n  halt(\"createClone\");\n}\nexports.createClone = createClone;\nObject.assign(createClone, clone);\nfunction createAssertClone() {\n  halt(\"createAssertClone\");\n}\nexports.createAssertClone = createAssertClone;\nObject.assign(createAssertClone, assertClone);\nfunction createIsClone() {\n  halt(\"createIsClone\");\n}\nexports.createIsClone = createIsClone;\nObject.assign(createIsClone, isClone);\nfunction createValidateClone() {\n  halt(\"createValidateClone\");\n}\nexports.createValidateClone = createValidateClone;\nObject.assign(createValidateClone, validateClone);\nfunction createPrune() {\n  halt(\"createPrune\");\n}\nexports.createPrune = createPrune;\nObject.assign(createPrune, prune);\nfunction createAssertPrune() {\n  halt(\"createAssertPrune\");\n}\nexports.createAssertPrune = createAssertPrune;\nObject.assign(createAssertPrune, assertPrune);\nfunction createIsPrune() {\n  halt(\"createIsPrune\");\n}\nexports.createIsPrune = createIsPrune;\nObject.assign(createIsPrune, isPrune);\nfunction createValidatePrune() {\n  halt(\"createValidatePrune\");\n}\nexports.createValidatePrune = createValidatePrune;\nObject.assign(createValidatePrune, validatePrune);\nfunction halt(name) {\n  throw new Error(\"Error on typia.\".concat(name, \"(): no transform has been configured. Configure the \\\"tsconfig.json\\\" file following the [README.md#setup](https://github.com/samchon/typia#setup)\"));\n}","map":{"version":3,"names":["Namespace_1","require","__exportStar","exports","assert","halt","Object","assign","Namespace","assertType","is","validate","assertEquals","equals","validateEquals","application","assertParse","isParse","validateParse","stringify","assertStringify","isStringify","validateStringify","metadata","random","clone","assertClone","isClone","validateClone","prune","assertPrune","isPrune","validatePrune","createAssert","createAssertType","createIs","createValidate","createAssertEquals","createEquals","createValidateEquals","createIsParse","createAssertParse","createValidateParse","createStringify","createAssertStringify","createIsStringify","createValidateStringify","createRandom","createClone","createAssertClone","createIsClone","createValidateClone","createPrune","createAssertPrune","createIsPrune","createValidatePrune","name","Error","concat"],"sources":["C:\\Users\\aidan\\OneDrive\\Desktop\\spotify\\node_modules\\typia\\src\\module.ts"],"sourcesContent":["import { Namespace } from \"./functional/Namespace\";\n\nimport { IMetadataApplication } from \"./metadata/IMetadataApplication\";\nimport { IJsonApplication } from \"./schemas/IJsonApplication\";\n\nimport { IRandomGenerator } from \"./IRandomGenerator\";\nimport { IValidation } from \"./IValidation\";\nimport { Primitive } from \"./Primitive\";\nimport { TypeGuardError } from \"./TypeGuardError\";\n\nexport * from \"./schemas/IJsonApplication\";\nexport * from \"./schemas/IJsonComponents\";\nexport * from \"./schemas/IJsonSchema\";\nexport * from \"./IRandomGenerator\";\nexport * from \"./IValidation\";\nexport * from \"./Primitive\";\nexport * from \"./TypeGuardError\";\n\n/* ===========================================================\n    SINGLE FUNCTIONS\n        - BASIC VALIDATORS\n        - STRICT VALIDATORS\n        - JSON FUNCTIONS\n        - MISCELLANEOUS\n==============================================================\n    BASIC VALIDATORS\n----------------------------------------------------------- */\n/**\n * Asserts a value type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T`. Otherwise, the\n * value is following the type `T`, just input parameter would be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link is} function instead.\n * Otherwise you want to know all the errors, {@link validate} is the way to go.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link assertEquals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function assert<T>(input: T): T;\n\n/**\n * Asserts a value type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T`. Otherwise, the\n * value is following the type `T`, just input parameter would be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link is} function instead.\n * Otherwise, you want to know all the errors, {@link validate} is the way to go.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link assertEquals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value casted as `T`\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function assert<T>(input: unknown): T;\n\n/**\n * @internal\n */\nexport function assert(): never {\n    halt(\"assert\");\n}\nObject.assign(assert, Namespace.assert(\"assert\"));\n\n/**\n * Asserts a value type.\n *\n * Duplicated function of {@link assert} for `typescript-is` users.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n * @deprecated\n */\nexport function assertType<T>(input: T): T;\n\n/**\n * Asserts a value type.\n *\n * Duplicated function of {@link assert} for `typescript-is` users.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n * @deprecated\n */\nexport function assertType<T>(input: unknown): T;\n\n/**\n * @internal\n */\nexport function assertType(): never {\n    halt(\"assertType\");\n}\nObject.assign(assertType, Namespace.assert(\"assertType\"));\n\n/**\n * Tests a value type.\n *\n * Tests a parametric value type and returns whether it's following the type `T` or not.\n * If the parametric value is matched with the type `T`, `true` value would be returned.\n * Otherwise, the parametric value is not following the type `T`, `false` value would be\n * returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assert} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validate} function would be useful.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link equals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function is<T>(input: T): input is T;\n\n/**\n * Tests a value type.\n *\n * Tests a parametric value type and returns whether it's following the type `T` or not.\n * If the parametric value is matched with the type `T`, `true` value would be returned.\n * Otherwise, the parametric value is not following the type `T`, `false` value would be\n * returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assert} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validate} function would be useful.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link equals} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function is<T>(input: unknown): input is T;\n\n/**\n * @internal\n */\nexport function is(): never {\n    halt(\"is\");\n}\nObject.assign(is, Namespace.assert(\"is\"));\n\n/**\n * Validates a value type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T`. Of course, if the parametric value is following the type `T`, the\n * {@link IValidation.errors} array would be empty and {@link IValidation.success}\n * would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function validate<T>(input: T): IValidation<T>;\n\n/**\n * Validates a value type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T`. Of course, if the parametric value is following the type `T`, the\n * {@link IValidation.errors} array would be empty and {@link IValidation.success}\n * would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function validate<T>(input: unknown): IValidation<T>;\n\n/**\n * @internal\n */\nexport function validate(): never {\n    halt(\"validate\");\n}\nObject.assign(validate, Namespace.validate());\n\n/* -----------------------------------------------------------\n    STRICT VALIDATORS\n----------------------------------------------------------- */\n/**\n * Asserts equality between a value and its type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T` or some superfluous\n * property that is not listed on the type `T` has been found. Otherwise, the value is\n * following the type `T` without any superfluous property, just input parameter would\n * be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link equals} function instead.\n * Otherwise, you want to know all the errors, {@link validateEquals} is the way to go.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link assert} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function assertEquals<T>(input: T): T;\n\n/**\n * Asserts equality between a value and its type.\n *\n * Asserts a parametric value type and throws a {@link TypeGuardError} with detailed\n * reason, if the parametric value is not following the type `T` or some superfluous\n * property that is not listed on the type `T` has been found. Otherwise, the value is\n * following the type `T` without any superfluous property, just input parameter would\n * be returned.\n *\n * If what you want is not asserting but just knowing whether the parametric value is\n * following the type `T` or not, you can choose the {@link equals} function instead.\n * Otherwise, you want to know all the errors, {@link validateEquals} is the way to go.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link assert} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be asserted\n * @returns Parametric input value casted as `T`\n * @throws A {@link TypeGuardError} instance with detailed reason\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function assertEquals<T>(input: unknown): T;\n\n/**\n * @internal\n */\nexport function assertEquals(): never {\n    halt(\"assertEquals\");\n}\nObject.assign(assertEquals, Namespace.assert(\"assertEquals\"));\n\n/**\n * Tests equality between a value and its type.\n *\n * Tests a parametric value type and returns whether it's equivalent to the type `T`\n * or not. If the parametric value is matched with the type `T` and there's not any\n * superfluous property that is not listed on the type `T`, `true` value would be\n * returned. Otherwise, the parametric value is not following the type `T` or some\n * superfluous property exists, `false` value would be returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assertEquals} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validateEquals} function would be useful.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link is} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is equivalent to the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function equals<T>(input: T): input is T;\n\n/**\n * Tests equality between a value and its type.\n *\n * Tests a parametric value type and returns whether it's equivalent to the type `T`\n * or not. If the parametric value is matched with the type `T` and there's not any\n * superfluous property that is not listed on the type `T`, `true` value would be\n * returned. Otherwise, the parametric value is not following the type `T` or some\n * superfluous property exists, `false` value would be returned.\n *\n * If what you want is not just knowing whether the parametric value is following the\n * type `T` or not, but throwing an exception with detailed reason, you can choose\n * {@link assertEquals} function instead. Also, if you want to know all the errors with\n * detailed reasons, {@link validateEquals} function would be useful.\n *\n * On the other hand, if you want to allow superfluous property that is not enrolled\n * to the type `T`, you can use {@link is} function instead.\n *\n * @template T Type of the input value\n * @param input A value to be tested\n * @returns Whether the parametric value is equivalent to the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function equals<T>(input: unknown): input is T;\n\n/**\n * @internal\n */\nexport function equals(): never {\n    halt(\"equals\");\n}\nObject.assign(equals, Namespace.is());\n\n/**\n * Validates equality between a value and its type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T` or some superfluous property that is not listed on the type `T` has been\n * found. Of course, if the parametric value is following the type `T` and no\n * superfluous property exists, the {@link IValidation.errors} array would be empty\n * and {@link IValidation.success} would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function validateEquals<T>(input: T): IValidation<T>;\n\n/**\n * Validates equality between a value and its type.\n *\n * Validates a parametric value type and archives all the type errors into an\n * {@link IValidation.errors} array, if the parametric value is not following the\n * type `T` or some superfluous property that is not listed on the type `T` has been\n * found. Of course, if the parametric value is following the type `T` and no\n * superfluous property exists, the {@link IValidation.errors} array would be empty\n * and {@link IValidation.success} would have the `true` value.\n *\n * If what you want is not finding all the error, but asserting the parametric value\n * type with exception throwing, you can choose {@link assert} function instead.\n * Otherwise, you just want to know whether the parametric value is matched with the\n * type `T`, {@link is} function is the way to go.\n *\n * On the other and, if you don't want to allow any superfluous property that is not\n * enrolled to the type `T`, you can use {@link validateEquals} function instead.\n *\n * @template Type of the input value\n * @param input A value to be validated\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function validateEquals<T>(input: unknown): IValidation<T>;\n\n/**\n * @internal\n */\nexport function validateEquals(): never {\n    halt(\"validateEquals\");\n}\nObject.assign(validateEquals, Namespace.validate());\n\n/* -----------------------------------------------------------\n    JSON FUNCTIONS\n----------------------------------------------------------- */\n/**\n * > You must configure the generic argument `T`.\n *\n * JSON Schema Application.\n *\n * Creates a JSON schema application which contains both main JSON schemas and components.\n * Note that, all of the object types are stored in the {@link IJsonApplication.components}\n * property for the `$ref` referencing.\n *\n * Also, `typia.application()` has additional generic arguments, *Purpose*.\n * As JSON schema definitions used by `swagger` and `ajv` are different a little bit,\n * you should configure the *Purpose* appropriately.\n *\n * For an example, `ajv` has an extra property \"$recursiveRef\" that are not exists\n * in the standard JSON schema definition spec. Otherwise, `swagger` can't identify\n * the tuple definition.\n *\n * @template Types Tuple of target types\n * @template Purpose Purpose of the JSON schema`\n * @template Prefix Prefix of the JSON components referenced by `$ref` tag\n * @return JSON schema application\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function application(): never;\n\n/**\n * JSON Schema Application.\n *\n * Creates a JSON schema application which contains both main JSON schemas and components.\n * Note that, all of the object types are stored in the {@link IJsonApplication.components}\n * property for the `$ref` referencing.\n *\n * Also, `typia.application()` has additional generic arguments, *Purpose*.\n * As JSON schema definitions used by `swagger` and `ajv` are different a little bit,\n * you should configure the *Purpose* appropriately.\n *\n * For an example, `ajv` has an extra property \"$recursiveRef\" that are not exists\n * in the standard JSON schema definition spec. Otherwise, `swagger` can't identify\n * the tuple definition.\n *\n * @template Types Tuple of target types\n * @template Purpose Purpose of the JSON schema\n * @template Prefix Prefix of the JSON components referenced by `$ref` tag\n * @return JSON schema application\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function application<\n    Types extends unknown[],\n    Purpose extends \"swagger\" | \"ajv\" = \"swagger\",\n    Prefix extends string = Purpose extends \"swagger\"\n        ? \"#/components/schemas\"\n        : \"components#/schemas\",\n>(): IJsonApplication;\n\n/**\n * @internal\n */\nexport function application(): never {\n    halt(\"application\");\n}\n\n/**\n * > You must configure the generic argument `T`.\n *\n * Safe `JSON.parse()` function with type assertion.\n *\n * `typia.assertParse()` is a combination function of `JSON.parse()` and {@link assert}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type assertion.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * throws {@link TypeGuardError}. Otherwise, there's no problem on the parsed value,\n * the parsed value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function assertParse(input: string): never;\n\n/**\n * Safe `JSON.parse()` function with type assertion.\n *\n * `typia.assertParse()` is a combination function of `JSON.parse()` and {@link assert}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type assertion.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * throws {@link TypeGuardError}. Otherwise, there's no problem on the parsed value,\n * the parsed value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function assertParse<T>(input: string): T;\n\n/**\n * @internal\n */\nexport function assertParse<T>(): T {\n    halt(\"assertParse\");\n}\nObject.assign(assertParse, Namespace.assert(\"assertParse\"));\n\n/**\n * > You must configure the generic argument `T`.\n *\n * Safe `JSON.parse()` function with type checking.\n *\n * `typia.isParse()` is a combination function of `JSON.parse()` and {@link is}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type checking.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns `null` value. Otherwise, there's no problem on the parsed value, the parsed\n * value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value when exact type, otherwise `null`\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function isParse(input: string): never;\n\n/**\n * Safe `JSON.parse()` function with type checking.\n *\n * `typia.isParse()` is a combination function of `JSON.parse()` and {@link is}.\n * Therefore, it convers a JSON (JavaScript Object Notation) string to a `T` typed\n * instance with type checking.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns `null` value. Otherwise, there's no problem on the parsed value, the parsed\n * value would be returned.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Parsed value when exact type, otherwise `null`\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function isParse<T>(input: string): T | null;\n\n/**\n * @internal\n */\nexport function isParse<T>(): T | null {\n    halt(\"isParse\");\n}\nObject.assign(isParse, is);\n\n/**\n * > You must configure the generic argument `T`.\n *\n * Safe `JSON.parse()` function with detailed type validation.\n *\n * `typia.validateParse()` is a combination function of `JSON.parse()` and\n * {@link validate}. Therefore, it convers a JSON (JavaScript Object Notation) string\n * to a `T` typed instance with detailed type validation.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns {@link IValidation.IFailure} value with detailed error reasons. Otherwise,\n * there's no problem on the parsed value, the parsed value would be stored in `data`\n * property of the output {@link IValidation.ISuccess} instance.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Validation result with JSON parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function validateParse(input: string): never;\n\n/**\n * Safe `JSON.parse()` function with detailed type validation.\n *\n * `typia.validateParse()` is a combination function of `JSON.parse()` and\n * {@link validate}. Therefore, it convers a JSON (JavaScript Object Notation) string\n * to a `T` typed instance with detailed type validation.\n *\n * In such reason, when parsed JSON string value is not matched with the type `T`, it\n * returns {@link IValidation.IFailure} value with detailed error reasons. Otherwise,\n * there's no problem on the parsed value, the parsed value would be stored in `data`\n * property of the output {@link IValidation.ISuccess} instance.\n *\n * @template T Expected type of parsed value\n * @param input JSON string\n * @returns Validation result with JSON parsed value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function validateParse<T>(input: string): IValidation<T>;\n\n/**\n * @internal\n */\nexport function validateParse<T>(): IValidation<T> {\n    halt(\"validateParse\");\n}\nObject.assign(validateParse, validate);\n\n/**\n * 8x faster `JSON.stringify()` function.\n *\n * Converts an input value to a JSON (JavaScript Object Notation) string, about 8x faster\n * than the native `JSON.stringify()` function. The 5x faster principle is because\n * it writes an optimized JSON conversion plan, only for the type `T`.\n *\n * For reference, this `typia.stringify()` does not validate the input value type.\n * It just believes that the input value is following the type `T`. Therefore, if you\n * can't ensure the input value type, it would be better to call one of below functions\n * instead.\n *\n *  - {@link assertStringify}\n *  - {@link isStringify}\n *  - {@link validateStringify}\n *\n * @template T Type of the input value\n * @param input A value to be converted\n * @return JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function stringify<T>(input: T): string;\n\n/**\n * @internal\n */\nexport function stringify(): never {\n    halt(\"stringify\");\n}\nObject.assign(stringify, Namespace.stringify(\"stringify\"));\n\n/**\n * 5x faster `JSON.stringify()` function with type assertion.\n *\n * `typia.assertStringify()` is a combination function of {@link assert} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there's no problem on the `input` value, JSON\n * string would be returned.\n *\n * For reference, with type assertion, it is even 5x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be asserted and converted\n * @return JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function assertStringify<T>(input: T): string;\n\n/**\n * 5x faster `JSON.stringify()` function with type assertion.\n *\n * `typia.assertStringify()` is a combination function of {@link assert} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there's no problem on the `input` value, JSON\n * string would be returned.\n *\n * For reference, with type assertion, it is even 5x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be asserted and converted\n * @return JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function assertStringify<T>(input: T): unknown;\n\n/**\n * @internal\n */\nexport function assertStringify(): string {\n    halt(\"assertStringify\");\n}\nObject.assign(assertStringify, Namespace.assert(\"assertStringify\"));\nObject.assign(assertStringify, Namespace.stringify(\"assertStringify\"));\n\n/**\n * 7x faster `JSON.stringify()` function with type checking.\n *\n * `typia.stringify()` is a combination function of {@link is} and\n * {@link stringify}. Therefore, it converts an input value to JSON\n * (JavaScript Object Notation) string, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value. Otherwise, there's no problem on the `input` value, JSON string would\n * be returned.\n *\n * For reference, with type checking, it is even 7x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @return JSON string value when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function isStringify<T>(input: T): string | null;\n\n/**\n * 7x faster `JSON.stringify()` function with type checking.\n *\n * `typia.isStringify()` is a combination function of {@link is} and\n * {@link stringify}. Therefore, it converts an input value to JSON\n * (JavaScript Object Notation) string, with type checking.\n *f\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value. Otherwise, there's no problem on the `input` value, JSON string would\n * be returned.\n *\n * For reference, with type checking, it is even 7x times faster than the native\n * `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @return JSON string value when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function isStringify<T>(input: unknown): string | null;\n\n/**\n * @internal\n */\nexport function isStringify(): string | null {\n    halt(\"isStringify\");\n}\n\nObject.assign(isStringify, Namespace.is());\nObject.assign(isStringify, Namespace.stringify(\"isStringify\"));\n\n/**\n * 5x faster `JSON.stringify()` function with detailed type validation.\n *\n * `typia.validateStringify()` is a combination function of {@link validate} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with detailed type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there's no\n * problem on the `input` value, JSON string would be stored in `data` property of\n * the output {@link IValidation.ISuccess} instance.\n *\n * For reference, with detailed type validation, it is even 5x times faster than the\n * native `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @returns Validation result with JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function validateStringify<T>(input: T): IValidation<string>;\n\n/**\n * 5x faster `JSON.stringify()` function with detailed type validation.\n *\n * `typia.validateStringify()` is a combination function of {@link validate} and\n * {@link stringify}. Therefore, it converts an input value to JSON (JavaScript Object\n * Notation) string, with detailed type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there's no\n * problem on the `input` value, JSON string would be stored in `data` property of\n * the output {@link IValidation.ISuccess} instance.\n *\n * For reference, with detailed type validation, it is even 5x times faster than the\n * native `JSON.stringify()` function. So, just enjoy the safe and fast JSON conversion\n * with confidence.\n *\n * @template T Type of the input value\n * @param input A value to be checked and converted\n * @returns Validation result with JSON string value\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function validateStringify<T>(input: unknown): IValidation<string>;\n\n/**\n * @internal\n */\nexport function validateStringify(): IValidation<string> {\n    halt(\"validateStringify\");\n}\nObject.assign(validateStringify, Namespace.validate());\nObject.assign(validateStringify, Namespace.stringify(\"validateStringify\"));\n\n/* -----------------------------------------------------------\n    MISCELLANEOUS\n----------------------------------------------------------- */\n/**\n * @internal\n */\nexport function metadata(): never;\n\n/**\n * @internal\n */\nexport function metadata<Types extends unknown[]>(): IMetadataApplication;\n\n/**\n * @internal\n */\nexport function metadata(): never {\n    halt(\"metadata\");\n}\n\n/**\n * > You must configure the generic argument `T`.\n *\n * Generate random data.\n *\n * Generates a random data following type the `T`.\n *\n * For reference, this `typia.random()` function generates only primitive type.\n * If there're some methods in the type `T` or its nested instances, those would\n * be ignored. Also, when the type `T` has a `toJSON()` method, its return type\n * would be generated instead.\n *\n * @template T Type of data to generate\n * @param generator Random data generator\n * @return Randomly generated data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function random(generator?: Partial<IRandomGenerator>): never;\n\n/**\n * Generate random data.\n *\n * Generates a random data following type the `T`.\n *\n * For reference, this `typia.random()` function generates only primitive type.\n * If there're some methods in the type `T` or its nested instances, those would\n * be ignored. Also, when the type `T` has a `toJSON()` method, its return type\n * would be generated instead.\n *\n * @template T Type of data to generate\n * @param generator Random data generator\n * @return Randomly generated data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function random<T>(generator?: Partial<IRandomGenerator>): Primitive<T>;\n\n/**\n * @internal\n */\nexport function random(): never {\n    halt(\"random\");\n}\nObject.assign(random, Namespace.random());\n\n/**\n * Clone a data.\n *\n * Clones an instance following type `T`. If the target *input* value or its member\n * variable contains a class instance that is having a `toJSON()` method, its return\n * value would be cloned.\n *\n * For reference, this `typia.clone()` function does not validate the input value type.\n * It just believes that the input value is following the type `T`. Therefore, if you\n * can't ensure the input value type, it would be better to call {@link assertClone}\n * function instead.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function clone<T>(input: T): Primitive<T>;\n\n/**\n * @internal\n */\nexport function clone(): never {\n    halt(\"clone\");\n}\nObject.assign(clone, Namespace.clone(\"clone\"));\n\n/**\n * Clone a data with type assertion.\n *\n * Clones an instance following type `T`, with type assertion. If the target `input`\n * value or its member variable contains a class instance that is having a `toJSON()`\n * method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there's no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function assertClone<T>(input: T): Primitive<T>;\n\n/**\n * Clone a data with type assertion.\n *\n * Clones an instance following type `T`, with type assertion. If the target `input`\n * value or its member variable contains a class instance that is having a `toJSON()`\n * method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there's no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function assertClone<T>(input: unknown): Primitive<T>;\n\n/**\n * @internal\n */\nexport function assertClone(): never {\n    halt(\"assertClone\");\n}\nObject.assign(assertClone, Namespace.assert(\"assertClone\"));\nObject.assign(assertClone, Namespace.clone(\"assertClone\"));\n\n/**\n * Clone a data with type checking.\n *\n * Clones an instance following type `T`, with type checking. If the target `input`\n * value or its member variable contains a class instance that is having a `toJSON()`\n * method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value instead. Otherwise, there's no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function isClone<T>(input: T): Primitive<T> | null;\n\n/**\n * Clone a data with type checking.\n *\n * Clones an instance following type `T`, with type checking. If the target `input`\n * value or its member variable contains a class instance that is having a `toJSON()`\n * method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `null` value instead. Otherwise, there's no problem on the `input` value, cloned\n * data would be returned.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @return Cloned data when exact type, otherwise null\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function isClone<T>(input: unknown): Primitive<T> | null;\n\n/**\n * @internal\n */\nexport function isClone(): never {\n    halt(\"isClone\");\n}\nObject.assign(isClone, Namespace.is());\nObject.assign(isClone, Namespace.clone(\"isClone\"));\n\n/**\n * Clone a data with detailed type validation.\n *\n * Clones an instance following type `T`, with detailed type validation. If the target\n * `input` value or its member variable contains a class instance that is having a\n * `toJSON()` method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.Failure} value. Otherwise, there's no problem on the `input`\n * value, cloned data would be stored in `data` property of the output\n * {@link IValidation.Success} instance.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @returns Validation result with cloned value\n */\nexport function validateClone<T>(input: T): IValidation<Primitive<T>>;\n\n/**\n * Clone a data with detailed type validation.\n *\n * Clones an instance following type `T`, with detailed type validation. If the target\n * `input` value or its member variable contains a class instance that is having a\n * `toJSON()` method, its return value would be cloned.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.Failure} value. Otherwise, there's no problem on the `input`\n * value, cloned data would be stored in `data` property of the output\n * {@link IValidation.Success} instance.\n *\n * @template T Type of the input value\n * @param input A value to be cloned\n * @returns Validation result with cloned value\n */\nexport function validateClone<T>(input: unknown): IValidation<Primitive<T>>;\n\n/**\n * @internal\n */\nexport function validateClone(): never {\n    halt(\"validateClone\");\n}\nObject.assign(validateClone, Namespace.validate());\nObject.assign(validateClone, Namespace.clone(\"validateClone\"));\n\n/**\n * Prune, erase superfluous properties.\n *\n * Remove every superfluous properties from the `input` object, even including nested\n * objects. Note that, as every superfluous properties would be deleted, you never can\n * read those superfluous properties after calling this `prune()` function.\n *\n * For reference, this `typia.prune()` function does not validate the input value type.\n * It just believes that the input value is following the type `T`. Therefore, if you\n * can't ensure the input value type, it would better to call one of below functions\n * instead.\n *\n *   - {@link assertPrune}\n *   - {@link isPrune}\n *   - {@link validatePrune}\n *\n * @template T Type of the input value\n * @param input Target instance to prune\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function prune<T extends object>(input: T): void;\n\n/**\n * @internal\n */\nexport function prune(): never {\n    halt(\"prune\");\n}\nObject.assign(prune, Namespace.prune(\"prune\"));\n\n/**\n * Prune, erase superfluous properties, with type assertion.\n *\n * `typia.assertPrune()` is a combination function of {@link assert} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there's no problem on the `input` value, its\n * every superfluous properties would be removed, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to assert and prune\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function assertPrune<T>(input: T): T;\n\n/**\n * Prune, erase superfluous properties, with type assertion.\n *\n * `typia.assertPrune()` is a combination function of {@link assert} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type assertion.\n *\n * In such reason, when `input` value is not matched with the type `T`, it throws an\n * {@link TypeGuardError}. Otherwise, there's no problem on the `input` value, its\n * every superfluous properties would be removed, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to assert and prune\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function assertPrune<T>(input: unknown): T;\n\n/**\n * @internal\n */\nexport function assertPrune(): unknown {\n    halt(\"assertPrune\");\n}\nObject.assign(assertPrune, Namespace.assert(\"assertPrune\"));\nObject.assign(assertPrune, Namespace.prune(\"assertPrune\"));\n\n/**\n * Prune, erase superfluous properties, with type checking.\n *\n * `typia.assertPrune()` is a combination function of {@link is} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `false` value. Otherwise, there's no problem on the `input` value, it returns\n * `true` after removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to check and prune\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function isPrune<T>(input: T): input is T;\n\n/**\n * Prune, erase superfluous properties, with type checking.\n *\n * `typia.assertPrune()` is a combination function of {@link is} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type checking.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * `false` value. Otherwise, there's no problem on the `input` value, it returns\n * `true` after removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to check and prune\n * @returns Whether the parametric value is following the type `T` or not\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function isPrune<T>(input: unknown): input is T;\n\n/**\n * @internal\n */\nexport function isPrune(): never {\n    halt(\"isPrune\");\n}\nObject.assign(isPrune, Namespace.is());\nObject.assign(isPrune, Namespace.prune(\"isPrune\"));\n\n/**\n * Prune, erase superfluous properties, with type validation.\n *\n * `typia.validatePrune()` is a combination function of {@link validate} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there's\n * no problem on the `input` value, it returns {@link IValidation.ISucess} value after\n * removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to validate and prune\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function validatePrune<T>(input: T): IValidation<T>;\n\n/**\n * Prune, erase superfluous properties, with type validation.\n *\n * `typia.validatePrune()` is a combination function of {@link validate} and {@link prune}.\n * Therefore, it removes every superfluous properties from the `input` object including\n * nested objects, with type validation.\n *\n * In such reason, when `input` value is not matched with the type `T`, it returns\n * {@link IValidation.IFailure} value with detailed error reasons. Otherwise, there's\n * no problem on the `input` value, it returns {@link IValidation.ISucess} value after\n * removing every superfluous properties, including nested objects.\n *\n * @template T Type of the input value\n * @param input Target instance to validate and prune\n * @returns Validation result\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function validatePrune<T>(input: unknown): IValidation<T>;\n\n/**\n * @internal\n */\nexport function validatePrune<T>(): IValidation<T> {\n    halt(\"validatePrune\");\n}\nObject.assign(validatePrune, Namespace.prune(\"validatePrune\"));\nObject.assign(validatePrune, Namespace.validate());\n\n/* ===========================================================\n    FACTORY FUNCTIONS\n        - BASIC VALIDATORS\n        - STRICT VALIDATORS\n        - JSON FUNCTIONS\n        - MISCELLANEOUS\n==============================================================\n    BASIC VALIDATORS\n----------------------------------------------------------- */\n/**\n * Creates a reusable {@link assert} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createAssert(): never;\n\n/**\n * Creates a reusable {@link assert} function.\n *\n * @template T Type of the input value\n * @returns A reusable `assert` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createAssert<T>(): (input: unknown) => T;\n\n/**\n * @internal\n */\nexport function createAssert<T>(): (input: unknown) => T {\n    halt(\"createAssert\");\n}\nObject.assign(createAssert, assert);\n\n/**\n * Creates a reusable {@link assertType} function.\n *\n * Duplicated function of {@link createAssert} for `typescript-is` users.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n * @deprecated\n */\nexport function createAssertType(): never;\n\n/**\n * Creates a reusable {@link assertType} function.\n *\n * Duplicated function of {@link createAssert} for `typescript-is` users.\n *\n * @template T Type of the input value\n * @returns A reusable `assert` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n * @deprecated\n */\nexport function createAssertType<T>(): (input: unknown) => T;\n\n/**\n * @internal\n */\nexport function createAssertType<T>(): (input: unknown) => T {\n    halt(\"createAssertType\");\n}\nObject.assign(createAssertType, assertType);\n\n/**\n * Creates a reusable {@link is} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createIs(): never;\n\n/**\n * Creates a reusable {@link is} function.\n *\n * @template T Type of the input value\n * @returns A reusable `is` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createIs<T>(): (input: unknown) => input is T;\n\n/**\n * @internal\n */\nexport function createIs<T>(): (input: unknown) => input is T {\n    halt(\"createIs\");\n}\nObject.assign(createIs, is);\n\n/**\n * Creates a reusable {@link validate} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createValidate(): never;\n\n/**\n * Creates a reusable {@link validate} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validate` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createValidate<T>(): (input: unknown) => IValidation<T>;\n\n/**\n * @internal\n */\nexport function createValidate(): (input: unknown) => IValidation {\n    halt(\"createValidate\");\n}\nObject.assign(createValidate, validate);\n\n/* -----------------------------------------------------------\n    STRICT VALIDATORS\n----------------------------------------------------------- */\n/**\n * Creates a reusable {@link assertEquals} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createAssertEquals(): never;\n\n/**\n * Creates a reusable {@link assertEquals} function.\n *\n * @template T Type of the input value\n * @returns A reusable `assertEquals` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createAssertEquals<T>(): (input: unknown) => T;\n\n/**\n * @internal\n */\nexport function createAssertEquals<T>(): (input: unknown) => T {\n    halt(\"createAssertEquals\");\n}\nObject.assign(createAssertEquals, assertEquals);\n\n/**\n * Creates a reusable {@link equals} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createEquals(): never;\n\n/**\n * Creates a reusable {@link equals} function.\n *\n * @template T Type of the input value\n * @returns A reusable `equals` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createEquals<T>(): (input: unknown) => input is T;\n\n/**\n * @internal\n */\nexport function createEquals<T>(): (input: unknown) => input is T {\n    halt(\"createEquals\");\n}\nObject.assign(createEquals, equals);\n\n/**\n * Creates a reusable {@link validateEquals} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createValidateEquals(): never;\n\n/**\n * Creates a reusable {@link validateEquals} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validateEquals` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createValidateEquals<T>(): (input: unknown) => IValidation<T>;\n\n/**\n * @internal\n */\nexport function createValidateEquals(): (input: unknown) => IValidation {\n    halt(\"createValidateEquals\");\n}\nObject.assign(createValidateEquals, validateEquals);\n\n/* -----------------------------------------------------------\n    JSON FUNCTIONS\n----------------------------------------------------------- */\n/**\n * Creates a reusable {@link isParse} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createIsParse(): never;\n\n/**\n * Creates a reusable {@link isParse} function.\n *\n * @template T Expected type of parsed value\n * @returns A reusable `isParse` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createIsParse<T>(): (input: string) => Primitive<T> | null;\n\n/**\n * @internal\n */\nexport function createIsParse<T>(): (input: string) => Primitive<T> | null {\n    halt(\"createIsParse\");\n}\nObject.assign(createIsParse, isParse);\n\n/**\n * Creates a reusable {@link assertParse} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createAssertParse(): never;\n\n/**\n * Creates a reusable {@link assertParse} function.\n *\n * @template T Expected type of parsed value\n * @returns A reusable `assertParse` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createAssertParse<T>(): (input: string) => Primitive<T>;\n\n/**\n * @internal\n */\nexport function createAssertParse<T>(): (input: string) => Primitive<T> {\n    halt(\"createAssertParse\");\n}\nObject.assign(createAssertParse, assertParse);\n\n/**\n * Creates a reusable {@link validateParse} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createValidateParse(): never;\n\n/**\n * Creates a reusable {@link validateParse} function.\n *\n * @template T Expected type of parsed value\n * @returns A reusable `validateParse` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createValidateParse<T>(): (\n    input: string,\n) => IValidation<Primitive<T>>;\n\n/**\n * @internal\n */\nexport function createValidateParse<T>(): (\n    input: string,\n) => IValidation<Primitive<T>> {\n    halt(\"createValidateParse\");\n}\nObject.assign(createValidateParse, validateParse);\n\n/**\n * Creates a reusable {@link stringify} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createStringify(): never;\n\n/**\n * Creates a reusable {@link stringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `stringify` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createStringify<T>(): (input: T) => string;\n\n/**\n * @internal\n */\nexport function createStringify<T>(): (input: T) => string {\n    halt(\"createStringify\");\n}\nObject.assign(createStringify, stringify);\n\n/**\n * Creates a reusable {@link assertStringify} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createAssertStringify(): never;\n\n/**\n * Creates a reusable {@link assertStringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `assertStringify` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createAssertStringify<T>(): (input: unknown) => string;\n\n/**\n * @internal\n */\nexport function createAssertStringify(): (input: unknown) => string {\n    halt(\"createAssertStringify\");\n}\nObject.assign(createAssertStringify, assertStringify);\n\n/**\n * Creates a reusable {@link isStringify} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createIsStringify(): never;\n\n/**\n * Creates a reusable {@link isStringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isStringify` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createIsStringify<T>(): (input: unknown) => string | null;\n\n/**\n * @internal\n */\nexport function createIsStringify(): (input: unknown) => string | null {\n    halt(\"createIsStringify\");\n}\nObject.assign(createIsStringify, isStringify);\n\n/**\n * Creates a reusable {@link validateStringify} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createValidateStringify(): never;\n\n/**\n * Creates a reusable {@link validateStringify} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validateStringify` function\n\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createValidateStringify<T>(): (\n    input: unknown,\n) => IValidation<string>;\n\n/**\n * @internal\n */\nexport function createValidateStringify(): (\n    input: unknown,\n) => IValidation<string> {\n    halt(\"createValidateStringify\");\n}\nObject.assign(createValidateStringify, validateStringify);\n\n/* -----------------------------------------------------------\n    MISCELLANEOUS\n----------------------------------------------------------- */\n/**\n * Creates a reusable {@link random} function.\n *\n * @danger You have to specify the generic argument `T`\n * @param generator Random data generator\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createRandom(generator?: Partial<IRandomGenerator>): never;\n\n/**\n * Creates a resuable {@link random} function.\n *\n * @template T Type of the input value\n * @param generator Random data generator\n * @returns A reusable `random` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createRandom<T>(\n    generator?: Partial<IRandomGenerator>,\n): () => Primitive<T>;\n\n/**\n * @internal\n */\nexport function createRandom(): never {\n    halt(\"createRandom\");\n}\nObject.assign(createRandom, random);\n\n/**\n * Creates a reusable {@link clone} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createClone(): never;\n\n/**\n * Creates a resuable {@link clone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createClone<T>(): (input: T) => Primitive<T>;\n\n/**\n * @internal\n */\nexport function createClone(): never {\n    halt(\"createClone\");\n}\nObject.assign(createClone, clone);\n\n/**\n * Creates a reusable {@link assertClone} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createAssertClone(): never;\n\n/**\n * Creates a resuable {@link assertClone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createAssertClone<T>(): (input: unknown) => Primitive<T>;\n\n/**\n * @internal\n */\nexport function createAssertClone(): never {\n    halt(\"createAssertClone\");\n}\nObject.assign(createAssertClone, assertClone);\n\n/**\n * Creates a reusable {@link isClone} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createIsClone(): never;\n\n/**\n * Creates a resuable {@link isClone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createIsClone<T>(): (input: unknown) => Primitive<T> | null;\n\n/**\n * @internal\n */\nexport function createIsClone(): never {\n    halt(\"createIsClone\");\n}\nObject.assign(createIsClone, isClone);\n\n/**\n * Creates a reusable {@link validateClone} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createValidateClone(): never;\n\n/**\n * Creates a resuable {@link validateClone} function.\n *\n * @template T Type of the input value\n * @returns A reusable `clone` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createValidateClone<T>(): (\n    input: unknown,\n) => IValidation<Primitive<T>>;\n\n/**\n * @internal\n */\nexport function createValidateClone(): never {\n    halt(\"createValidateClone\");\n}\nObject.assign(createValidateClone, validateClone);\n\n/**\n * Creates a reusable {@link prune} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createPrune(): never;\n\n/**\n * Creates a resuable {@link prune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `prune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createPrune<T extends object>(): (input: T) => void;\n\n/**\n * @internal\n */\nexport function createPrune<T extends object>(): (input: T) => void {\n    halt(\"createPrune\");\n}\nObject.assign(createPrune, prune);\n\n/**\n * Creates a reusable {@link assertPrune} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createAssertPrune(): never;\n\n/**\n * Creates a resuable {@link assertPrune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isPrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createAssertPrune<T extends object>(): (input: T) => T;\n\n/**\n * @internal\n */\nexport function createAssertPrune<T extends object>(): (input: T) => T {\n    halt(\"createAssertPrune\");\n}\nObject.assign(createAssertPrune, assertPrune);\n\n/**\n * Creates a reusable {@link isPrune} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createIsPrune(): never;\n\n/**\n * Creates a resuable {@link isPrune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `isPrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createIsPrune<T extends object>(): (input: T) => input is T;\n\n/**\n * @internal\n */\nexport function createIsPrune<T extends object>(): (input: T) => input is T {\n    halt(\"createIsPrune\");\n}\nObject.assign(createIsPrune, isPrune);\n\n/**\n * Creates a reusable {@link validatePrune} function.\n *\n * @danger You have to specify the generic argument `T`\n * @return Nothing until specifying the generic argument `T`\n * @throws compile error\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createValidatePrune(): never;\n\n/**\n * Creates a resuable {@link validatePrune} function.\n *\n * @template T Type of the input value\n * @returns A reusable `validatePrune` function\n *\n * @author Jeongho Nam - https://github.com/samchon\n */\nexport function createValidatePrune<T extends object>(): (\n    input: T,\n) => IValidation<T>;\n\n/**\n * @internal\n */\nexport function createValidatePrune<T extends object>(): (\n    input: T,\n) => IValidation<T> {\n    halt(\"createValidatePrune\");\n}\nObject.assign(createValidatePrune, validatePrune);\n\n/**\n * @internal\n */\nfunction halt(name: string): never {\n    throw new Error(\n        `Error on typia.${name}(): no transform has been configured. Configure the \"tsconfig.json\" file following the [README.md#setup](https://github.com/samchon/typia#setup)`,\n    );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}