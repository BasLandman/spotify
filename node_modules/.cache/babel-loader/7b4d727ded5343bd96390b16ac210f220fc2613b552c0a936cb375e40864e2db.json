{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});","map":{"version":3,"names":[],"sources":["C:\\Users\\aidan\\OneDrive\\Desktop\\spotify\\node_modules\\typia\\src\\Primitive.ts"],"sourcesContent":["/**\n * Primitive type.\n *\n * `Primitive` is a type of TMP (Type Meta Programming) type who converts its argument as a\n * primitive type.\n *\n * If the target argument is a built-in class who returns its origin primitive type through\n * the `valueOf()` method like the `String` or `Number`, its return type would be the\n * `string` or `number`.\n *\n * Otherwise, the target argument is a type of custom class, all of its custom method would\n * be erased and its prototype would be changed to the primitive `object`. Therefore, return\n * type of the TMP type finally be the primitive object.\n *\n * In addition, if the target argument is a type of custom class and it has a special\n * method `toJSON()`, return type of this `Primitive` would be not `Primitive<Instance>`\n * but `Primitive<ReturnType<Instance.toJSON>>`.\n *\n * Before                  | After\n * ------------------------|----------------------------------------\n * `Boolean`               | `boolean`\n * `Number`                | `number`\n * `String`                | `string`\n * `Class`                 | `object`\n * `Class` with `toJSON()` | `Primitive<ReturnType<Class.toJSON>>`\n * Others                  | No change\n *\n * @template Instance Target argument type.\n * @author Jenogho Nam - https://github.com/samchon\n */\nexport type Primitive<T> = _Equal<T, _Primitive<T>> extends true\n    ? T\n    : _Primitive<T>;\n\ntype _Equal<X, Y> = X extends Y ? (Y extends X ? true : false) : false;\n\ntype _Primitive<Instance> = _ValueOf<Instance> extends object\n    ? Instance extends object\n        ? Instance extends _Native\n            ? {}\n            : Instance extends IJsonable<infer Raw>\n            ? _ValueOf<Raw> extends object\n                ? Raw extends object\n                    ? _PrimitiveObject<Raw> // object would be primitified\n                    : never // cannot be\n                : _ValueOf<Raw> // atomic value\n            : _PrimitiveObject<Instance> // object would be primitified\n        : never // cannot be\n    : _ValueOf<Instance>;\n\ntype _PrimitiveObject<Instance extends object> = Instance extends Array<infer T>\n    ? _Primitive<T>[]\n    : {\n          [P in keyof Instance]: Instance[P] extends Function\n              ? never\n              : _Primitive<Instance[P]>;\n      };\n\ntype _ValueOf<Instance> = _IsValueOf<Instance, Boolean> extends true\n    ? boolean\n    : _IsValueOf<Instance, Number> extends true\n    ? number\n    : _IsValueOf<Instance, String> extends true\n    ? string\n    : Instance;\n\ntype _Native =\n    | Set<any>\n    | Map<any, any>\n    | WeakSet<any>\n    | WeakMap<any, any>\n    | Uint8Array\n    | Uint8ClampedArray\n    | Uint16Array\n    | Uint32Array\n    | BigUint64Array\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | BigInt64Array\n    | Float32Array\n    | Float64Array\n    | ArrayBuffer\n    | SharedArrayBuffer\n    | DataView;\n\ntype _IsValueOf<\n    Instance,\n    Object extends IValueOf<any>,\n> = Instance extends Object\n    ? Object extends IValueOf<infer Primitive>\n        ? Instance extends Primitive\n            ? false\n            : true // not Primitive, but Object\n        : false // cannot be\n    : false;\n\ninterface IValueOf<T> {\n    valueOf(): T;\n}\n\ninterface IJsonable<T> {\n    toJSON(): T;\n}\n"],"mappings":""},"metadata":{},"sourceType":"script","externalDependencies":[]}