{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeGuardError = void 0;\nvar TypeGuardError = function (_super) {\n  __extends(TypeGuardError, _super);\n  function TypeGuardError(props) {\n    var _newTarget = this.constructor;\n    var _this = _super.call(this, props.message || \"Error on \".concat(props.method, \"(): invalid type\").concat(props.path ? \" on \".concat(props.path) : \"\", \", expect to be \").concat(props.expected)) || this;\n    var proto = _newTarget.prototype;\n    if (Object.setPrototypeOf) Object.setPrototypeOf(_this, proto);else _this.__proto__ = proto;\n    _this.method = props.method;\n    _this.path = props.path;\n    _this.expected = props.expected;\n    _this.value = props.value;\n    return _this;\n  }\n  return TypeGuardError;\n}(Error);\nexports.TypeGuardError = TypeGuardError;","map":{"version":3,"names":["TypeGuardError","_super","__extends","props","_this","call","message","concat","method","path","expected","proto","_newTarget","prototype","Object","setPrototypeOf","__proto__","value","Error","exports"],"sources":["C:\\Users\\aidan\\OneDrive\\Desktop\\spotify\\node_modules\\typia\\src\\TypeGuardError.ts"],"sourcesContent":["export class TypeGuardError extends Error {\n    public readonly method: string;\n    public readonly path: string | undefined;\n    public readonly expected: string;\n    public readonly value: any;\n\n    public constructor(props: TypeGuardError.IProps) {\n        // MESSAGE CONSTRUCTION\n        super(\n            props.message ||\n                `Error on ${props.method}(): invalid type${\n                    props.path ? ` on ${props.path}` : \"\"\n                }, expect to be ${props.expected}`,\n        );\n\n        // INHERITANCE POLYFILL\n        const proto = new.target.prototype;\n        if (Object.setPrototypeOf) Object.setPrototypeOf(this, proto);\n        else (this as any).__proto__ = proto;\n\n        // ASSIGN MEMBERS\n        this.method = props.method;\n        this.path = props.path;\n        this.expected = props.expected;\n        this.value = props.value;\n    }\n}\nexport namespace TypeGuardError {\n    export interface IProps {\n        method: string;\n        path?: string;\n        expected: string;\n        value: any;\n        message?: string;\n    }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,IAAAA,cAAA,aAAAC,MAAA;EAAoCC,SAAA,CAAAF,cAAA,EAAAC,MAAA;EAMhC,SAAAD,eAAmBG,KAA4B;;IAA/C,IAAAC,KAAA,GAEIH,MAAA,CAAAI,IAAA,OACIF,KAAK,CAACG,OAAO,IACT,YAAAC,MAAA,CAAYJ,KAAK,CAACK,MAAM,sBAAAD,MAAA,CACpBJ,KAAK,CAACM,IAAI,GAAG,OAAAF,MAAA,CAAOJ,KAAK,CAACM,IAAI,CAAE,GAAG,EAAE,qBAAAF,MAAA,CACvBJ,KAAK,CAACO,QAAQ,CAAE,CACzC;IAGD,IAAMC,KAAK,GAAGC,UAAA,CAAWC,SAAS;IAClC,IAAIC,MAAM,CAACC,cAAc,EAAED,MAAM,CAACC,cAAc,CAACX,KAAI,EAAEO,KAAK,CAAC,CAAC,KACxDP,KAAY,CAACY,SAAS,GAAGL,KAAK;IAGpCP,KAAI,CAACI,MAAM,GAAGL,KAAK,CAACK,MAAM;IAC1BJ,KAAI,CAACK,IAAI,GAAGN,KAAK,CAACM,IAAI;IACtBL,KAAI,CAACM,QAAQ,GAAGP,KAAK,CAACO,QAAQ;IAC9BN,KAAI,CAACa,KAAK,GAAGd,KAAK,CAACc,KAAK;;EAC5B;EACJ,OAAAjB,cAAC;AAAD,CAAC,CA1BmCkB,KAAK;AAA5BC,OAAA,CAAAnB,cAAA,GAAAA,cAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}